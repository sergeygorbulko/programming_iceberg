## KIS (KISS) метод: _Keep It Simple (and Stupid)_
Чаще всего под “KIS метод” имеют в виду принцип **KISS**: _делай проще_. Смысл — **выбирать самое простое решение, которое реально закрывает задачу**, и не усложнять систему “на всякий случай”.
### Зачем это нужно
- **Меньше багов**: чем меньше сущностей/ветвлений/магии — тем меньше мест, где можно ошибиться.
- **Проще поддержка**: через месяц ты (или коллега) быстрее поймёшь код.
- **Дешевле изменения**: простые решения обычно легче расширять и рефакторить.
- **Быстрее доставка**: меньше “архитектуры ради архитектуры”.

## Как применять на практике
### 1) Начинай с минимального работающего решения
- Сначала реши задачу “в лоб”, но аккуратно.
- Оптимизации/обобщения — **только когда появились реальные требования** (нагрузка, новые кейсы, дублирование).

### 2) Убирай “умность”, которая не даёт ценности
Сигналы, что стало слишком сложно:
- слишком много уровней абстракции “ради красоты”;
- обилие конфигураций/флагов/плагинов, которые никто не использует;
- сложные паттерны там, где хватило бы пары функций.

### 3) Делай код очевидным
- Говорящие имена, прямой поток выполнения.
- Явные условия вместо “хитрых” трюков.
- Меньше “магических” значений и неочевидных побочных эффектов.

### 4) Разделяй, но не дроби без необходимости
KISS не про “всё в один файл”, а про **разумные границы**:
- один класс/модуль — одна ответственность,
- но не 20 классов для простого сценария.

## Частые ошибки при “KIS”
- **Путать простое с примитивным**: “простое” — это понятное и поддерживаемое, а не “на коленке”.
- **Рано оптимизировать**: производительность важна, но сначала нужна корректность и ясность.
- **Избегать абстракций вообще**: иногда абстракция _упрощает_ (например, общий интерфейс для двух реально разных реализаций).

## Быстрый чек-лист KISS для кода
Перед тем как коммитить, спроси себя:
1. Можно ли объяснить решение в 2–3 предложениях?
2. Есть ли здесь обобщение “на будущее”, которое пока не нужно?
3. Можно ли убрать уровень абстракции и не потерять ясность?
4. Поймёт ли это новый разработчик без экскурсии?

## Мини-пример (в духе KISS)
Вместо “универсального” обработчика с плагинами/реестрами/рефлексией — обычная функция с `when`, если вариантов мало и они известны.
Когда вариантов станет много и появятся требования расширяемости — тогда уже имеет смысл реестр/стратегии.
Если скажешь, в каком контексте ты услышал “KIS” (код, менеджмент, обучение, рефакторинг), я подстрою примеры под твою ситуацию и стек (например, Kotlin/Spring).